// call.c

inherit F_CLEAN_UP;

int main(object me, string arg)
{
	string objname, func, param, euid;
	object obj;
	mixed *args, result;
	int i,my_level,ob_level;
	mapping no_call;
	mapping type=([]);
	
	seteuid(getuid());
	no_call=PUNLISH_D->query_translate();
	if(no_call[me->query("id")])
	{
	type=no_call[me->query("id")];
	if(type["no_call"])	return notify_fail("你现在在服刑期间，不能使用这个指令。\n");
	}
	if( arg ) {
		if( sscanf(arg, "-%s %s", euid, arg)==2 ) {
			if( (string)SECURITY_D->get_status(me) != "(admin)" )
				return notify_fail("你不能设定自己的 euid。\n");
			seteuid(euid);
		}
		else
			seteuid( geteuid(this_player(1)) );

		if( sscanf(arg, "%s->%s(%s)", objname, func, param)!=3 )
			return notify_fail("指令格式：call <物件>-><函数>( <参数>, ... )\n");
	} else
		return notify_fail("指令格式：call <物件>-><函数>( <参数>, ... )\n");

	
	if (objname == "me") {
	  obj = me;
	}
	else
	  obj = present(objname, environment(me));
	if(!obj) obj = present(objname, me);
	if(!obj) obj = find_player(objname);
    if(!obj) obj=find_object(objname);
    if(!obj) obj=find_living(objname);
	if(!obj) obj = find_object(resolve_path(me->query("cwd"), objname));
	if(!obj) return notify_fail("找不到指定的物件。\n");

	my_level = wiz_level(me);
	ob_level = wiz_level(obj);
	if( ob_level > my_level)
		return notify_fail("不要对上司开玩笑。\n");
	if( userp(obj) ){
		if( obj != me || obj->query("id")!="guest" ) 
		{
//		   if( (string)SECURITY_D->get_status(obj) == "(player)" )
		   if(ob_level == 0 )
		   {

//	if( (string)SECURITY_D->get_status(me) == "(wizard)" &&  
//		obj->query("id",1) != "guest")
		   if(my_level <= 3 )
			   return notify_fail("玩家的事请找 arch 以上解决\n");
		   log_file("static/CALL_PLAYERS",
		   sprintf("%s(%s) call %s(%s)->%s(%s) on %s\n",
		   me->name(1), geteuid(me), obj->name(1), geteuid(obj), func, 
		   param, ctime(time()) ) );
		   }
		   else
                   log_file("static/CALL_WIZARD",
                   sprintf("%s(%s) call %s(%s)->%s(%s) on %s\n",
                   me->name(1), geteuid(me), obj->name(1), geteuid(obj), func, 
                   param, ctime(time()) ) );
		}
	} else if( !master()->valid_write( base_name(obj), me, "set" ) )
		return notify_fail("你没有直接呼叫这个物件的函数的权力。\n");

	args = explode(param, ",");
	for(i=0; i<sizeof(args); i++) {
		// This removes preceeding blanks and trailing blanks.
		parse_command(args[i], environment(me), "%s", args[i]);
		if( sscanf(args[i], "%d", args[i]) ) continue;
		if( sscanf(args[i], "\"%s\"", args[i]) ) continue;
		//args[i] = restore_variable(args[i]);
	}

	args = ({ func }) + args;

	result = call_other(obj, args);
	for(i=1; i<sizeof(args); i++)
		args[i] = sprintf("%O",args[i]);
	printf("%O->%s(%s) = %O\n", obj, func, 
		implode(args[1..sizeof(args)-1], ", "), result);
	return 1;
}

int help(object me)
{
write(@HELP
指令格式 : call <物件>-><函数>(<参数>, ...... )
 
呼叫<物件>里的<函数>并传入相关<参数>.
 
HELP
    );
    return 1;
}
