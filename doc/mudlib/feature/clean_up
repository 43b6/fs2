
□ F_CLEAN_UP - 提供继承这项特征的物件一个标准的 clean_up 函数。

    每当一个物件在隔了一段固定长度时间没有被其他物件参考到，MudOS 会呼
叫该物件的 clean_up 函数以检查这个物件是否有继续存在的必要，也就是说，
如果这个物件有一段时间没有被使用到，也许物件已经没有用了，可以将它从记
忆体中清除以节省空间，例如：一个很久没有人走过的房间。

    clean up 时间的长短是在 MudOS 的 runtime config 档里设定的。所有可
以被 clone 的物件、房间、指令处理物件、以及非长驻型 daemon都应该要继承
这项特征以便能在物件不被使用到时加以摧毁并释放出所占记忆体。
 
    当此函数传回 1 时，意思是告诉 MudOS 「我现在暂时要继续留在记忆体中
，但是如果再隔一段固定长度时间这个物件仍然没有被其他物件参考到，请你再
呼叫一次我的 clean_up() 函数”，若传回 0 或是 clean_up  函数没有被定义
，则 MudOS 会假设这个物件不需要 clean up这种服务，以后就不会再呼叫这个
物件的 clean_up()。

标准的 clean_up() 判定程序：
 
    首先，如果这个物件是一个使用者 (用 interactive() 决定)，此函数传回
 1，因为使用者发呆过久是在 heart beat 里处理的。
 
    接下来，如果这个物件是在另一个物件里，例如一个房间里的怪物、袋子里
的物品等等，我们改呼叫含有这个物件的房间或袋子的 clean_up() ，这样做有
两个主要理由：如果同一个房间里有不能被 clean up 的物件，如玩家，那么我
们不希望任何物件在他们面前凭空消失，而且，如果一个存在于另一物件中的物
件能够被清除，容纳它的物件必定也能够被清除，如果容纳它的物件不能被清除
，那么这个物件也必定不能被清除，如玩家身上的物件，因此我们让容纳这个物
件的物件来决定要不要清除，因为清除一个物件的同时，也会清除这个物件里的
所有物件。
 
    如果这个物件并不是在另一个物件里，而是一个房间，我们还必须检查是否
有玩家在这个房间里，以免玩家发呆了一会儿就被踢到最后乐园去。
 
    最后，经过以上各个关卡，我们判定这个物件已经没有存在的必要，所以我
们将这个物件摧毁，传回 0 用以告知 MudOS 这个物件已经「不见了”以后不用
再检查它是否需要 clean up  。
 
[Elon 12-12-94]
[Annihilator 12-13-94]
