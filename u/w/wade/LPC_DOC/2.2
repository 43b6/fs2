第二章  第二节：变数的宣告与设定

  我们可以这样说，每个 LPC 程式都是由叙述组成，底下先介绍两种基本型的，一是
变数的宣告，另一个是变数值的设定。

===========================================================================
  1  inherit ROOM;
  2  void create()
  3  {
  4    int	flag;
  5
  6    flag = 1;
  7    write ("flag = " + flag + "\n");
  8    setup();
  9  }
===========================================================================

    其中第四行就是宣告一个 flag 变数，而由其前面的 int 告诉 driver 说，
这个变数要用「整数”型态来管理(如储存与运算)，而第六行则指定一个值 1 给 flag
变数。

    所有的 LPMud 执行程式包含以下的资料型态:
  int , string, object, int *, string *, mixed *, void
    有的执行程式有下列的资料种类:
  float, mapping, float *, mapping *, function, enum, struct, char

    其中 MudOS 支援 float, mapping, float *, mapping *, function

    资料型态可以用在下列四个地方：
    ．整体变数的宣告，
    ．函数的传回值，
    ．函数的参数的宣告，
    ．函数内局部变数的宣告。

    LPC 比 C 更自由的地方在于，一般而言，它忽略了资料型态要认真要求，如同上例
第七行 write() 是用来把一个字串「印”给使用者看的函数，所以想来其参数应该是字
串，但是在此我们用了 "flag = " + flag + "\n" 这种字串加法，而且值得特别一提的
是，其中还有一个原本是「整数”型态的变数，也拿来当成字串作字串加法。
    上例会印出 "flag = 1" 并换行，其中 "\n" 表换行。

    为什么需要在使用变数前先宣告其型态呢？因为目前为止，大部分的电脑只能处理
「完全正确”的事情，一步一步照设定的规则来做，所以为了储存一项资讯，程式设计师
必须告诉电脑储存资讯所需的空间，什么时候配置空间给它，以及如何运作。
    上面提到例子中的第七行，我们再举不完全能「执行”的例子：

    int x;
    string y;

    x = 1;
    y = "1";
    write (x + 0 + "\n");
    write (y + 0 + "\n");

    上面的例子会印出
    1
    10

    之所以会这样，是因为此时电脑对 x + 0 是采「整数”方式运算， 1 + 0 当然
等于 1, 所以印出 1 是非常合理的。
    如同稍早曾提到的 write ("flag = " + flag + "\n"); 这个叙述已经有字串相加
，而且把整数也当成字串加进来了，上例的 y + 0 其实相当于 y + "0"，所以印出来的
值变成 10 就不难想像了。这也就是为什么我们一定要先告诉电脑我们要处理的变数的
型态。对于不确定的结果，‘奉劝读者先印出其结果无误后再使用’。
    另外，有点小技巧要告诉各位读者，可以的话，尽量把变数宣告在即将使用之前。
当然，有人喜欢将所有变数集中起来宣告，方便寻找变数的宣告，但在某种状况下这种
情况会稍微浪费点记忆体空间。而且就可读性来说，技巧的建议应该较易阅读。
